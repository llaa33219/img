// Firebase 및 기타 라이브러리 가져오기
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-app.js";
import { getFirestore, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore.js";
import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-storage.js";
function _0x2bc9(){const _0x5ac041=['355duVLjO','imgshare-2.appspot.com','980ILDfqs','624LJyhjV','addEventListener','12126PPXFSe','innerText','imgshare-2.firebaseapp.com','익명\x20인증\x20실패:','16880376UWxfdU','uploadContainer','30663VaLbFY','1205516RHPukT','uploadButton','G-C97WZLE7J0','toggleButton','getElementById','error','then','210472wJqHwd','114988mlPyvB','11mUKplL','fileNameDisplay','catch','익명\x20인증\x20실패:\x20','fileInput','message','1:669732206491:web:c57c3238a46b37c86c133e','click','29526CuTAoo','7vJbQqg','status','AIzaSyCa6O_jCJ7XyxU5oOdoNqmMkbqpohKfLyE','fileSelectButton','익명\x20로그인\x20성공','imgshare-2'];_0x2bc9=function(){return _0x5ac041;};return _0x2bc9();}const _0x431ac3=_0x263f;(function(_0x12549a,_0x33da47){const _0x33f27f=_0x263f,_0x19fec5=_0x12549a();while(!![]){try{const _0x587c63=-parseInt(_0x33f27f(0x9b))/0x1+parseInt(_0x33f27f(0x93))/0x2+-parseInt(_0x33f27f(0xb0))/0x3*(-parseInt(_0x33f27f(0xae))/0x4)+-parseInt(_0x33f27f(0xab))/0x5*(-parseInt(_0x33f27f(0xa4))/0x6)+-parseInt(_0x33f27f(0xa5))/0x7*(-parseInt(_0x33f27f(0x9a))/0x8)+parseInt(_0x33f27f(0x92))/0x9*(parseInt(_0x33f27f(0xad))/0xa)+-parseInt(_0x33f27f(0x9c))/0xb*(parseInt(_0x33f27f(0x90))/0xc);if(_0x587c63===_0x33da47)break;else _0x19fec5['push'](_0x19fec5['shift']());}catch(_0xdc39da){_0x19fec5['push'](_0x19fec5['shift']());}}}(_0x2bc9,0x66d5a));function _0x263f(_0x4326b0,_0x365566){const _0x2bc985=_0x2bc9();return _0x263f=function(_0x263f10,_0x535cf8){_0x263f10=_0x263f10-0x8d;let _0x14e399=_0x2bc985[_0x263f10];return _0x14e399;},_0x263f(_0x4326b0,_0x365566);}import{getAuth,signInAnonymously}from'https://www.gstatic.com/firebasejs/10.13.1/firebase-auth.js';const firebaseConfig={'apiKey':_0x431ac3(0xa7),'authDomain':_0x431ac3(0x8e),'projectId':_0x431ac3(0xaa),'storageBucket':_0x431ac3(0xac),'messagingSenderId':'669732206491','appId':_0x431ac3(0xa2),'measurementId':_0x431ac3(0x95)},app=initializeApp(firebaseConfig),db=getFirestore(app),storage=getStorage(app),auth=getAuth();signInAnonymously(auth)[_0x431ac3(0x99)](()=>{const _0x52ed71=_0x431ac3;console['log'](_0x52ed71(0xa9));})[_0x431ac3(0x9e)](_0x1af812=>{const _0x55e50c=_0x431ac3;console[_0x55e50c(0x98)](_0x55e50c(0x8f),_0x1af812),document[_0x55e50c(0x97)](_0x55e50c(0xa6))[_0x55e50c(0x8d)]=_0x55e50c(0x9f)+_0x1af812[_0x55e50c(0xa1)];});const fileInput=document['getElementById'](_0x431ac3(0xa0)),fileSelectButton=document[_0x431ac3(0x97)](_0x431ac3(0xa8)),fileNameDisplay=document[_0x431ac3(0x97)](_0x431ac3(0x9d)),uploadButton=document[_0x431ac3(0x97)](_0x431ac3(0x94)),uploadContainer=document[_0x431ac3(0x97)](_0x431ac3(0x91)),toggleButton=document[_0x431ac3(0x97)](_0x431ac3(0x96)),statusElement=document[_0x431ac3(0x97)](_0x431ac3(0xa6)),apiKey=_0x431ac3(0xa7);fileSelectButton[_0x431ac3(0xaf)](_0x431ac3(0xa3),()=>{const _0x3c87b5=_0x431ac3;fileInput[_0x3c87b5(0xa3)]();});

// 파일 선택 시 파일명 표시
fileInput.addEventListener('change', () => {
  if (fileInput.files.length > 0) {
    const fileNames = Array.from(fileInput.files).map(file => file.name).join(', ');
    fileNameDisplay.innerText = fileNames;
  } else {
    fileNameDisplay.innerText = "파일 선택 안됨";
  }
});

// 클립보드에서 이미지/비디오 붙여넣기 처리
document.addEventListener('paste', (event) => {
  const clipboardItems = event.clipboardData.items;
  let mediaFile = null;

  for (const item of clipboardItems) {
    if (item.type.indexOf('image') !== -1 || item.type.indexOf('video') !== -1) {
      mediaFile = item.getAsFile();
      break;
    }
  }

  if (mediaFile) {
    const fileExtension = mediaFile.name.split('.').pop().toLowerCase();
    const allowedImageExtensions = ['png', 'bmp', 'jpg', 'jpeg', 'webp', 'gif'];
    const allowedVideoExtensions = ['mp4', 'webm', 'ogg', 'mov', 'avi'];

    if (!allowedImageExtensions.includes(fileExtension) && !allowedVideoExtensions.includes(fileExtension)) {
      statusElement.innerText = "허용되지 않은 파일 형식입니다.";
      return;
    }

    const dataTransfer = new DataTransfer();
    dataTransfer.items.add(mediaFile);
    fileInput.files = dataTransfer.files;
    fileNameDisplay.innerText = mediaFile.name;
    statusElement.innerText = "클립보드에서 미디어가 선택되었습니다.";
  } else {
    statusElement.innerText = "클립보드에 이미지나 비디오가 없습니다.";
  }
});

// 이미지 안전성 검사 함수
async function getImageSafetyScore(imageFile) {
  async function analyzeImageContent(base64Image) {
    const response = await fetch(`https://vision.googleapis.com/v1/images:annotate?key=${apiKey}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        requests: [
          {
            image: { content: base64Image },
            features: [
              { type: "SAFE_SEARCH_DETECTION" },
              { type: "LABEL_DETECTION", maxResults: 20 },
              { type: "TEXT_DETECTION" },
              { type: "FACE_DETECTION" }
            ]
          }
        ]
      })
    });
    if (!response.ok) {
      throw new Error('API 호출 실패');
    }
    const result = await response.json();
    return result.responses[0];
  }

  // 단순 변환 함수 - 이전에 제시한 복잡한 변환들을 그대로 사용해도 되며,
  // 여기서는 간소화 예제만 남깁니다.
  // 노이즈 우회 방지를 위해 이전처럼 다양한 변환을 모두 시도하십시오.
  async function transformImage(base64Str, options) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);

        // 필요하다면 여기에 미디안필터, 포스터라이즈, 색반전 등 다양한 전처리 추가
        // 노이즈 제거/특징 강조 필터들 적용 가능

        const newBase64 = canvas.toDataURL('image/png').split(',')[1];
        resolve(newBase64);
      };
      img.onerror = () => resolve(null);
      img.src = 'data:image/png;base64,' + base64Str;
    });
  }

  async function generateVariantsAndAnalyze(base64Image) {
    const variants = [base64Image];

    // 다양한 변환 옵션 추가
    const transformOptions = [
      { /* 원본 그대로 */ },
      { grayscale: true },
      { /* 미디안 필터 적용, 포스터라이즈, invert 등 구현 */ },
      // ... 다양한 변환 로직을 여기 넣어 노이즈 우회 방지
    ];

    for (const opts of transformOptions) {
      const transformed = await transformImage(base64Image, opts);
      if (transformed) {
        variants.push(transformed);
      }
    }

    const results = [];
    for (const variant of variants) {
      try {
        const response = await analyzeImageContent(variant);
        results.push(response);
      } catch (e) {
        console.error("변환 이미지 분석 실패:", e);
      }
    }
    return results;
  }

  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = async function(event) {
      const base64Image = event.target.result.split(',')[1];

      try {
        statusElement.innerText = "이미지 분석 중...";
        const analysisResults = await generateVariantsAndAnalyze(base64Image);

        // 여기서 노이즈 상황에 따른 처리 강화
        let isCensored = false;
        let reasons = [];

        const _0x17f369=_0xa027;function _0x4dc1(){const _0x16620f=['75445QsIZiO','14SWaZJP','pornographic','damn','breasts','candidate','80928OAmWsV','shit','nude','1325190YJHiEK','torture','bitch','150752LKYuUr','disparage','158676PGHBkn','hate','genitals','sexual\x20activity','government','intercourse','insult','cruel','erotic','politics','brutal','porn','2099280qZKjEO','ㅅ1ㅂ','injury','국회의원','abuse','asshole','election','92352AUyyem','개새끼','vagina'];_0x4dc1=function(){return _0x16620f;};return _0x4dc1();}function _0xa027(_0xb42141,_0x53777a){const _0x4dc1f8=_0x4dc1();return _0xa027=function(_0xa027f1,_0x3ba025){_0xa027f1=_0xa027f1-0x1ba;let _0x424919=_0x4dc1f8[_0xa027f1];return _0x424919;},_0xa027(_0xb42141,_0x53777a);}(function(_0x201903,_0x39c572){const _0x4ebb5b=_0xa027,_0x3cdf6c=_0x201903();while(!![]){try{const _0x2dc31c=-parseInt(_0x4ebb5b(0x1c5))/0x1+-parseInt(_0x4ebb5b(0x1d1))/0x2+parseInt(_0x4ebb5b(0x1c2))/0x3+-parseInt(_0x4ebb5b(0x1cb))/0x4+-parseInt(_0x4ebb5b(0x1ce))/0x5+parseInt(_0x4ebb5b(0x1d3))/0x6+-parseInt(_0x4ebb5b(0x1c6))/0x7*(-parseInt(_0x4ebb5b(0x1bb))/0x8);if(_0x2dc31c===_0x39c572)break;else _0x3cdf6c['push'](_0x3cdf6c['shift']());}catch(_0x3d0bff){_0x3cdf6c['push'](_0x3cdf6c['shift']());}}}(_0x4dc1,0x23a27));const politicalKeywords=[_0x17f369(0x1dc),_0x17f369(0x1c1),_0x17f369(0x1d7),_0x17f369(0x1ca),'party','정당','정치','선거',_0x17f369(0x1be)],derogatoryKeywords=[_0x17f369(0x1d2),_0x17f369(0x1d4),'derogatory',_0x17f369(0x1d9),'비하','혐오'],cruelKeywords=[_0x17f369(0x1da),_0x17f369(0x1bd),_0x17f369(0x1bf),_0x17f369(0x1cf),_0x17f369(0x1dd),'잔인','피해','학대','고문','잔혹'],sexualKeywords=['nudity',_0x17f369(0x1db),_0x17f369(0x1ba),_0x17f369(0x1c7),'sex','sexual',_0x17f369(0x1d6),_0x17f369(0x1d8),_0x17f369(0x1c9),_0x17f369(0x1d5),'penis',_0x17f369(0x1c4),'buttocks',_0x17f369(0x1cd)],abusiveWordsEn=['fuck',_0x17f369(0x1cc),_0x17f369(0x1c8),_0x17f369(0x1d0),_0x17f369(0x1c0)],abusiveWordsKo=['시발','씨발',_0x17f369(0x1c3),'좆','시발놈','병신','미친년','지랄','ㅅㅂ','ㅽ','ㅄ','ㅂㅅ',_0x17f369(0x1bc),'ㅂ1ㅅ','시1발'];
        const abusiveWords = [...abusiveWordsEn, ...abusiveWordsKo];

        function checkKeywords(sourceText, keywords) {
          const normalized = sourceText.toLowerCase();
          return keywords.some(keyword => normalized.includes(keyword));
        }

        const censorIfPossibleOrAbove = ['POSSIBLE', 'LIKELY', 'VERY_LIKELY'];

        // 모든 변환 결과를 종합해 검열 여부 판단
        let anyLabelDetected = false; // 어떤 변환에서라도 라벨이 인식되었는지
        let foundSuspicious = false;  // 부적절 신호 감지 여부

        for (const result of analysisResults) {
          if (!result) continue;

          const safeSearch = result.safeSearchAnnotation;
          const labels = result.labelAnnotations || [];
          const textAnnotations = result.textAnnotations || [];
          const faceDetection = result.faceAnnotations;

          if (labels.length > 0) {
            anyLabelDetected = true;
          }

          // SafeSearch 판정
          // 노이즈 상황에서 더욱 빡세게:
          // adult/racy/violence가 POSSIBLE 이상이면 바로 검열
          if (safeSearch) {
            if (censorIfPossibleOrAbove.includes(safeSearch.adult)) {
              foundSuspicious = true; 
              reasons.push('성인/선정적 가능성 감지');
            }
            if (censorIfPossibleOrAbove.includes(safeSearch.racy)) {
              foundSuspicious = true;
              reasons.push('선정적 가능성 감지');
            }
            if (censorIfPossibleOrAbove.includes(safeSearch.violence)) {
              foundSuspicious = true;
              reasons.push('폭력적 가능성 감지');
            }
          }

          // 라벨에서 정치/비하/잔인/성적 키워드 감지 시 POSSIBLE 수준에서도 검열
          let labelDescriptions = labels.map(l => l.description.toLowerCase()).join(' ');
          if (checkKeywords(labelDescriptions, politicalKeywords)) {
            foundSuspicious = true; reasons.push('정치적 가능성 감지');
          }
          if (checkKeywords(labelDescriptions, derogatoryKeywords)) {
            foundSuspicious = true; reasons.push('비하적 가능성 감지');
          }
          if (checkKeywords(labelDescriptions, cruelKeywords)) {
            foundSuspicious = true; reasons.push('잔인한 가능성 감지');
          }
          if (checkKeywords(labelDescriptions, sexualKeywords)) {
            foundSuspicious = true; reasons.push('성적 키워드 감지');
          }

          // 텍스트 욕설
          if (textAnnotations.length > 0) {
            const detectedText = textAnnotations[0].description.toLowerCase();
            if (checkKeywords(detectedText, abusiveWords)) {
              foundSuspicious = true; reasons.push('욕설 감지');
            }
          }

          // 얼굴 감지 (노이즈가 있어도 얼굴이라 판단되면)
          if (faceDetection && faceDetection.length > 0) {
            const highConfidenceFaces = faceDetection.filter(f => (f.detectionConfidence || 0) > 0.7);
            if (highConfidenceFaces.length > 0) {
              // 얼굴 감지가 된다면, 어지간하면 선정적/폭력적 가능성과 결합 가능
              // 여기서는 얼굴 감지만으로 검열하지 않고, 위에서 성인/폭력 신호와 조합할 수 있음.
              // 필요하면 얼굴 감지만으로도 검열 강화 가능
            }
          }
        }

        // 최종 판단:
        // 노이즈로 인해 아무런 라벨이나 정보가 전혀 없는 경우(모든 변환 결과 labelAnnotations = 0, safeSearch 모두 VERY_UNLIKELY/UNKNOWN)만 비검열
        // 그 외에는 조금이라도 POSSIBLE 이상의 부적절 신호 발견 시 검열
        if (foundSuspicious) {
          isCensored = true;
        } else {
          // 만약 아무런 라벨도 없고 safeSearch가 전부 VERY_UNLIKELY or UNKNOWN일 경우만 비검열
          // 여기서는 anyLabelDetected를 사용했지만,
          // 더욱 엄밀하게 하려면 analysisResults를 다시 검사해서 모두 VERY_UNLIKELY인지 확인할 수도 있음.
          
          let allVeryUnlikely = true; 
          for (const result of analysisResults) {
            if (!result) continue;
            const safeSearch = result.safeSearchAnnotation;
            if (!safeSearch) continue;
            // 하나라도 POSSIBLE 이상이면 foundSuspicious가 true되었을 것이므로 여기 올 일 없음
            // 여기서는 전부 VERY_UNLIKELY인지 확인
            if (
              !(safeSearch.adult === 'VERY_UNLIKELY' && 
                safeSearch.racy === 'VERY_UNLIKELY' && 
                safeSearch.violence === 'VERY_UNLIKELY' &&
                safeSearch.medical === 'VERY_UNLIKELY' &&
                safeSearch.spoof === 'VERY_UNLIKELY')
            ) {
              allVeryUnlikely = false;
              break;
            }
          }

          // 라벨도 없고, allVeryUnlikely면 비검열, 아니면 가능성만으로 검열
          // 만약 라벨이 하나도 없고 allVeryUnlikely가 true라면 형체를 알아볼 수 없는 수준으로 판단
          if (!anyLabelDetected && allVeryUnlikely) {
            // 형체를 알 수 없으므로 비검열
            isCensored = false;
          } else {
            // 라벨이 하나라도 있거나 allVeryUnlikely가 아니면,
            // 이 경우 POSSIBLE도 못 잡았다는 것인데, 이 경우 부적절 신호가 전혀 없는 진짜 정상 이미지로 판단 가능
            // 여기서는 noise 상황 강화를 위해 
            // "아무것도 검출 안되면 비검열" 로 두므로
            // 여기서는 isCensored = false 유지
            // (원한다면 여기서도 더욱 빡세게 하고 싶다면 'foundSuspicious=true;'로 처리 가능)
            isCensored = false;
          }
        }

        resolve({ isCensored, reasons });
      } catch (error) {
        console.error("오류 발생:", error);
        statusElement.innerText = "이미지 분석 중 오류가 발생했습니다.";
        reject(error);
      }
    };

    reader.onerror = function(error) {
      console.error("파일 읽기 실패:", error);
      reject(error);
    };

    reader.readAsDataURL(imageFile);
  });
}

// 사이트 소리 음소거/복원 함수
function muteSiteSounds() {
  document.querySelectorAll('audio, video').forEach(el => {
    el.muted = true;
  });
}

function unmuteSiteSounds() {
  document.querySelectorAll('audio, video').forEach(el => {
    el.muted = false;
  });
}

// 동영상 프레임 분석 함수 (매 1초 간격)
async function analyzeVideoFrames(videoFile) {
  return new Promise((resolve, reject) => {
    const video = document.createElement('video');
    video.src = URL.createObjectURL(videoFile);
    video.crossOrigin = 'anonymous';
    video.load();

    video.addEventListener('loadeddata', async () => {
      const duration = video.duration;
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      let censored = false;
      for (let time = 0; time < duration; time += 1) {
        await new Promise(r => {
          video.currentTime = time;
          video.addEventListener('seeked', async function onSeeked() {
            video.removeEventListener('seeked', onSeeked);
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            canvas.toBlob(async (blob) => {
              if (!blob) {
                r();
                return;
              }
              const { isCensored } = await getImageSafetyScore(blob);
              if (isCensored) {
                censored = true;
              }
              r();
            }, 'image/png');
          });
        });
        if (censored) break;
      }

      if (censored) {
        resolve({ isCensored: true, reasons: ['비디오 프레임 검열'] });
      } else {
        resolve({ isCensored: false, reasons: [] });
      }
    });

    video.addEventListener('error', (e) => {
      reject(e);
    });
  });
}

// 파일 업로드
uploadButton.addEventListener('click', async () => {
  const mediaFiles = fileInput.files;
  if (mediaFiles.length === 0) {
    statusElement.innerText = "파일을 선택하세요.";
    return;
  }

  const allowedImageExtensions = ['png', 'bmp', 'jpg', 'jpeg', 'webp', 'gif'];
  const allowedVideoExtensions = ['mp4', 'webm', 'ogg', 'mov', 'avi'];
  let uploadedNames = [];
  let skippedFiles = [];

  // 동영상 있는지 확인
  const isAnyVideo = Array.from(mediaFiles).some(file => {
    const fileExtension = file.name.split('.').pop().toLowerCase();
    return allowedVideoExtensions.includes(fileExtension);
  });

  if (isAnyVideo) {
    muteSiteSounds();
  }

  try {
    for (const mediaFile of mediaFiles) {
      const fileNameParts = mediaFile.name.split('.');
      if (fileNameParts.length < 2) {
        statusElement.innerText = "파일에 확장자가 없습니다.";
        return;
      }
      const fileExtension = fileNameParts.pop().toLowerCase();
      const isImage = allowedImageExtensions.includes(fileExtension);
      const isVideo = allowedVideoExtensions.includes(fileExtension);

      if (!isImage && !isVideo) {
        statusElement.innerText = "허용되지 않은 파일 형식입니다.";
        return;
      }

      let censorshipReasons = [];
      let isCensored = false;

      if (isImage) {
        const result = await getImageSafetyScore(mediaFile);
        isCensored = result.isCensored;
        censorshipReasons = result.reasons;
      }

      if (isVideo) {
        statusElement.innerText = "동영상 프레임 분석 중...";
        const result = await analyzeVideoFrames(mediaFile);
        isCensored = result.isCensored;
        censorshipReasons = result.reasons;
      }

      if (isCensored) {
        skippedFiles.push({ name: mediaFile.name, reasons: censorshipReasons });
        continue;
      }

      try {
        statusElement.innerText = "업로드 중...";
        const uniqueName = Math.random().toString(36).substring(2, 15);
        const storageRef = ref(storage, uniqueName);
        await uploadBytes(storageRef, mediaFile);
        const downloadURL = await getDownloadURL(storageRef);
        await setDoc(doc(db, 'images', uniqueName), { url: downloadURL, censored: false, type: isVideo ? 'video' : 'image' });
        uploadedNames.push(uniqueName);
      } catch (error) {
        console.error("업로드 실패:", error);
        statusElement.innerText = "업로드 실패: " + error.message;
        return;
      }
    }

    if (uploadedNames.length > 0) {
      const imageUrl = `https://bloupla.net/img/?=${uploadedNames.join(',')}`;
      document.getElementById('linkBox').value = imageUrl;
      statusElement.innerText = "업로드 성공!";
    }

    if (skippedFiles.length > 0) {
      const skippedList = skippedFiles.map(file => `${file.reasons.join(', ')} (${file.name})`).join('; ');
      statusElement.innerText = `부적절한 내용이 감지되었습니다: ${skippedList}`;
    }
  } catch (error) {
    console.error("업로드 중 오류 발생:", error);
    statusElement.innerText = "업로드 중 오류가 발생했습니다.";
  } finally {
    if (isAnyVideo) {
      unmuteSiteSounds();
    }
  }
});

// URL에서 이미지/비디오 로드
async function loadImageFromUrl() {
  const urlParams = new URLSearchParams(window.location.search);
  const imageNamesParam = urlParams.get('');
  if (!imageNamesParam) return;

  const imageNames = imageNamesParam.split(',');

  if (imageNames.length > 0) {
    const imageContainer = document.getElementById('imageContainer');
    imageContainer.innerHTML = '';

    try {
      const downloadURLs = await Promise.all(imageNames.map(name => {
        const trimmedName = name.trim();
        const storageRef = ref(storage, trimmedName);
        return getDownloadURL(storageRef);
      }));

      await Promise.all(downloadURLs.map((url, index) => displayMedia(imageNames[index], url)));
    } catch (error) {
      console.error("이미지 로드 실패:", error);
      statusElement.innerText = "이미지 로드 중 오류가 발생했습니다.";
    }

    hideUploadUI();
  }
}

// 업로드 UI 숨기는 함수
function hideUploadUI() {
  uploadContainer.classList.add('hidden');
  toggleButton.style.display = 'flex';
}

// UI 표시/숨김 토글 버튼 클릭 시 처리
toggleButton.addEventListener('click', () => {
  if (uploadContainer.classList.contains('hidden')) {
    uploadContainer.classList.remove('hidden');
    toggleButton.innerText = '-';
  } else {
    uploadContainer.classList.add('hidden');
    toggleButton.innerText = '+';
  }
});

// '복사' 버튼 클릭 시 처리
document.getElementById('copyButton').addEventListener('click', () => {
  const linkBox = document.getElementById('linkBox');
  const linkText = linkBox.value;

  if (!navigator.clipboard) {
    linkBox.select();
    linkBox.setSelectionRange(0, 99999);
    try {
      const successful = document.execCommand('copy');
      if (successful) {
        alert('링크가 복사되었습니다!');
      } else {
        alert('링크 복사에 실패했습니다.');
      }
    } catch (err) {
      console.error('복사 실패:', err);
      alert('링크 복사에 실패했습니다.');
    }
  } else {
    navigator.clipboard.writeText(linkText)
      .then(() => {
        alert('링크가 복사되었습니다!');
      })
      .catch((err) => {
        console.error('복사 실패:', err);
        alert('링크 복사에 실패했습니다.');
      });
  }
});

// 미디어 표시 함수 (이미지 또는 동영상)
async function displayMedia(name, url) {
  try {
    const docRef = doc(db, 'images', name);
    const docSnap = await getDoc(docRef);
    let needsCensorship = false;
    let mediaType = 'image';

    if (docSnap.exists()) {
      needsCensorship = docSnap.data().censored;
      mediaType = docSnap.data().type || 'image';
    }

    const imageContainer = document.getElementById('imageContainer');
    const isImage = mediaType === 'image';
    const isVideo = mediaType === 'video';

    if (isImage || isVideo) {
      if (needsCensorship) {
        const censorshipMessage = document.createElement('div');
        censorshipMessage.classList.add('censorship-message');
        censorshipMessage.innerText = "부적절하다고 판단되어 검열되었습니다.";
        censorshipMessage.style.width = '40vw';
        censorshipMessage.style.height = 'auto';
        censorshipMessage.style.margin = '20px auto';
        censorshipMessage.style.textAlign = 'center';
        censorshipMessage.style.color = '#fff';
        censorshipMessage.style.backgroundColor = 'rgba(0,0,0,0.8)';
        censorshipMessage.style.padding = '20px';
        censorshipMessage.style.borderRadius = '10px';
        imageContainer.appendChild(censorshipMessage);
      } else {
        if (isImage) {
          const imgElement = document.createElement('img');
          imgElement.crossOrigin = 'anonymous';
          imgElement.src = url;
          imageContainer.appendChild(imgElement);

          imgElement.addEventListener('load', () => {
            if (imgElement.naturalWidth > imgElement.naturalHeight) {
              imgElement.classList.add('landscape');
            } else {
              imgElement.classList.add('portrait');
            }
          });

          imgElement.addEventListener('click', function () {
            imgElement.classList.toggle('expanded');
          });

          imgElement.addEventListener('contextmenu', function(event) {
            event.preventDefault();
            showCustomContextMenu(event, imgElement);
          });
        } else if (isVideo) {
          const videoElement = document.createElement('video');
          videoElement.src = url;
          videoElement.controls = true;
          videoElement.style.cursor = 'pointer';
          imageContainer.appendChild(videoElement);

          videoElement.addEventListener('loadedmetadata', () => {
            if (videoElement.videoWidth > videoElement.videoHeight) {
              videoElement.classList.add('landscape');
            } else {
              videoElement.classList.add('portrait');
            }
          });

          videoElement.addEventListener('contextmenu', function(event) {
            event.preventDefault();
            showCustomContextMenu(event, videoElement);
          });
        }
      }
    }
  } catch (error) {
    console.error("미디어 로드 실패:", error);
    statusElement.innerText = "미디어 로드 중 오류가 발생했습니다.";
  }
}

// 사용자 정의 컨텍스트 메뉴 표시 함수
function showCustomContextMenu(event, mediaElement) {
  const contextMenu = document.getElementById('customContextMenu');
  contextMenu.style.top = `${event.clientY}px`;
  contextMenu.style.left = `${event.clientX}px`;
  contextMenu.style.display = 'flex';
  contextMenu.style.flexDirection = 'column';

  contextMenu.currentMedia = mediaElement;
}

// 사용자 정의 컨텍스트 메뉴 숨김
function hideCustomContextMenu() {
  const contextMenu = document.getElementById('customContextMenu');
  contextMenu.style.display = 'none';
  contextMenu.currentMedia = null;
}

document.addEventListener('click', (event) => {
  const contextMenu = document.getElementById('customContextMenu');
  if (!contextMenu.contains(event.target)) {
    hideCustomContextMenu();
  }
});

// '이미지 복사' 버튼
document.getElementById('copyImage').addEventListener('click', async () => {
  const contextMenu = document.getElementById('customContextMenu');
  const mediaElement = contextMenu.currentMedia;
  if (!mediaElement) return;

  try {
    const link = mediaElement.src;
    await navigator.clipboard.writeText(link);
    alert('이미지/동영상 링크가 클립보드에 복사되었습니다!');
  } catch (error) {
    console.error('복사 실패:', error);
    alert('복사에 실패했습니다.');
  } finally {
    hideCustomContextMenu();
  }
});

// '이미지 다운로드' 버튼
document.getElementById('downloadImage').addEventListener('click', async () => {
  const contextMenu = document.getElementById('customContextMenu');
  const mediaElement = contextMenu.currentMedia;
  if (!mediaElement) return;

  try {
    const response = await fetch(mediaElement.src, { mode: 'cors' });
    if (!response.ok) {
      throw new Error('다운로드 실패');
    }
    const blob = await response.blob();
    const blobUrl = URL.createObjectURL(blob);

    const link = document.createElement('a');
    link.href = blobUrl;
    link.download = 'downloaded-media';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    URL.revokeObjectURL(blobUrl);
  } catch (error) {
    console.error('다운로드 실패:', error);
    alert('다운로드에 실패했습니다.');
  } finally {
    hideCustomContextMenu();
  }
});

// 페이지 로드 시 로드
window.onload = async () => {
  await loadImageFromUrl();
};
